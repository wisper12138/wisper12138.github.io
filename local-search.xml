<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode6</title>
    <link href="/2020/06/18/LeetCode6/"/>
    <url>/2020/06/18/LeetCode6/</url>
    
    <content type="html"><![CDATA[<h2 id="24-节点间通路"><a href="#24-节点间通路" class="headerlink" title="24.节点间通路"></a>24.<a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/" target="_blank" rel="noopener">节点间通路</a></h2><p><strong>思路：</strong>有向图可以用<strong>邻接表</strong>表示每个节点直接连接的节点，有了邻接表就可以用深度或广度优先搜索。</p><p><img src="2020-06-18-LeetCode6/image-20200615152343859.png" srcset="/img/loading.gif" alt="image"></p><p>以上图节点1为start为例，找1能到达的节点： </p><p>广度优先搜索：需要一个队列来存可以到达的节点，从1开始，到2，此时需要将2的邻接节点5加入到队列中，到4，再将4的邻接节点2加入到队列中，但是2重复了就不需要加了，因此还需要一个布尔数组判重，到5，此时将5的邻接4加入队列，但是重复了就不需要加了，5完了队列就空了，因此1能到达的节点都遍历了。顺序是1-2-4-5</p><p>深度优先搜索：1到2，此时将1的其他邻接存到栈中，找2的邻接5，然后将2的其他邻接存到栈中找5的邻接4，将5的其他邻接存到栈中，找4的邻接2，此时布尔数组判2重了，所以到头了，找4的其他邻接，没有，再取栈中元素是5的其他邻接，没有，再取栈中2的其他邻接没有，再取栈中1的其他邻接是4发现重复了，1也没有其他邻接了，栈空遍历结束。顺序是1-2-5-4。</p><pre><code class="java">class Solution {    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {        List&lt;Integer&gt;[] graphList = graphList(n,graph);        boolean[] marked = new boolean[n];        return dfs(graphList,start,target,marked);    }    //将图存为邻接表    private List&lt;Integer&gt;[] graphList(int n,int[][] graph){        List&lt;Integer&gt;[] graphList = new ArrayList[n];        for (int[] i:graph){            //建第i[0]位置的链表            if (graphList[i[0]]==null){                graphList[i[0]]=new ArrayList&lt;Integer&gt;();            }            //将第i[0]位置的元素存到第i[0]位置的链表            graphList[i[0]].add(i[1]);        }        return graphList;    }    //广度优先搜索    /*    private boolean bfs(List&lt;Integer&gt;[] graphList,int start,int target,boolean[] marked){        //用一个队列存能到达的节点        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        //将第一个元素入队列，并将判重数组对应的下标位置设为true        queue.add(start);        marked[start]=true;        while (!queue.isEmpty()){            int node = queue.poll();            if (graphList[node]==null)                continue;            for (Integer next:graphList[node]){                if (next==target)                    return true;                if (marked[next]){                    continue;                }                marked[next]=true;                queue.add(next);            }        }        return false;    }    *///深度优先搜索    private boolean dfs(List&lt;Integer&gt;[] graphList,int start,int target,boolean[] marked){        List&lt;Integer&gt; list =graphList[start];        if (list==null)            return false;        for (int i:list){            if (!marked[i]){                if (i==target)                    return true;                marked[i]=true;                if (dfs(graphList,i,target,marked))                    return true;            }        }        return false;    }}</code></pre><p>发现了一个只有3ms的方法，把start那个位置设为true，从这开始，对能到达的点设为true，再将其能到达的点所能到达的那些点也设为true。</p><pre><code class="java">class Solution {    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {        // 路径可达        boolean[] dp = new boolean[n];        for (int[] node : graph) {            // 若出发地为start 则设置出发地到目的地可达            dp[node[0]] = node[0] == start;        }        for (int[] node : graph) {            if(dp[node[0]]) {                dp[node[1]] = true;            }        }        //需要再执行一遍，否则遍历过的点再为true就不能遍历了，如[2,3][3,1][1,4],start=2，2为true，3为true，1为true，只遍历一遍4就无法设为true。        for (int[] node : graph) {            if(dp[node[0]]) {                dp[node[1]] = true;            }        }        return dp[target];    }}</code></pre><h2 id="25-最小高度树"><a href="#25-最小高度树" class="headerlink" title="25.最小高度树"></a>25.<a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/" target="_blank" rel="noopener">最小高度树</a></h2><p>思路：有序数组，所以每次选最中间的数为根节点，左边复制为新数组最中间为左节点，右边复制为新数组最中间为右节点，递归。</p><pre><code class="java">class Solution {    public TreeNode sortedArrayToBST(int[] nums) {        int l =nums.length;        int mid = l/2;        if (l==0)            return null;        TreeNode node = new TreeNode(nums[mid]);        node.left=sortedArrayToBST(Arrays.copyOfRange(nums,0,mid));        node.right=sortedArrayToBST(Arrays.copyOfRange(nums,mid+1,l));        return node;    }}</code></pre><p>优化：复制为新数组影响效率，用left和right标记左右新数组中间的位置。</p><pre><code class="java">class Solution {    public TreeNode sortedArrayToBST(int[] nums) {        return sortedArrayToBST(nums,0,nums.length-1);    }    public TreeNode sortedArrayToBST(int[] nums,int left,int right){        if (left&gt;right)            return null;        int mid = (left+right+1)/2;        TreeNode node = new TreeNode(nums[mid]);        node.left=sortedArrayToBST(nums,left,mid-1);        node.right=sortedArrayToBST(nums,mid+1,right);        return node;    }}</code></pre><h2 id="26-特定深度节点链表"><a href="#26-特定深度节点链表" class="headerlink" title="26.特定深度节点链表"></a>26.<a href="https://leetcode-cn.com/problems/list-of-depth-lcci/" target="_blank" rel="noopener">特定深度节点链表</a></h2><p><strong>思路：</strong>层次遍历，用一个队列保存一层的节点，最后返回的是链表数组，由于不知道树深，所以无法直接定义链表数组，可以先用存链表的链表，最后再转成数组。</p><pre><code class="java">class Solution {    public ListNode[] listOfDepth(TreeNode tree) {        if (tree==null)            return null;        List&lt;ListNode&gt; list = new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(tree);        while (!queue.isEmpty()){            //这一层节点数            int size =queue.size();            //head为头节点，rear用于尾插            ListNode head =null;            ListNode rear =null;            for (int i=0;i&lt;size;i++){                //每次出队一个树节点                TreeNode p = queue.poll();                //第一个节点为头节点                if (i==0){                     head = new ListNode(p.val);                     rear =head;                }else{                    ListNode cur =new ListNode(p.val);                    rear.next=cur;                    rear=cur;                }                //将当前树节点的左右孩子入队                if (p.left!=null){                    queue.add(p.left);                }                if (p.right!=null){                    queue.add(p.right);                }            }            //将这一层的单链表入链            list.add(head);        }        //转成数组//        ListNode[] res = new ListNode[list.size()];//        int i=0;//        for (ListNode node:list){//            res[i++]=node;//        }//        return res;        return list.toArray(new ListNode[list.size()]);    }}</code></pre><p>上面用for循环来处理一层，下面用size来控制一层</p><pre><code class="java">class Solution {    public ListNode[] listOfDepth(TreeNode tree) {        if (tree==null)            return null;        List&lt;ListNode&gt; list = new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(tree);        int size =1;        ListNode head =new ListNode(-1);        ListNode rear=head;        while (!queue.isEmpty()){            if (size&gt;0){                size--;                TreeNode t = queue.poll();                ListNode cur =new ListNode(t.val);                rear.next=cur;                rear=cur;                if (t.left!=null) {                    queue.add(t.left);                }                if (t.right!=null)                    queue.add(t.right);            }else{                //如果size等于0则表示上一层节点都加入到链表中了，需要将这个链表加入到list中                //然后当前队列中的元素都是下一层的，重新维护一个size。                list.add(head.next);                //需要将rear再回到头节点                rear=head;                size=queue.size();            }        }        //跳出while循环，最后一个链表没加到list中        list.add(head.next);        //转成数组        ListNode[] res = new ListNode[list.size()];        int i=0;        for (ListNode node:list){            res[i++]=node;        }        return res;    }}</code></pre><h2 id="27-检查平衡性"><a href="#27-检查平衡性" class="headerlink" title="27.检查平衡性"></a>27.<a href="https://leetcode-cn.com/problems/check-balance-lcci/" target="_blank" rel="noopener">检查平衡性</a></h2><p><strong>思路：</strong>根结点满足左右子树高度差不大于1，左孩子也满足，右孩子也满足，才能返回true，递归求高度。</p><pre><code class="java">class Solution {    public boolean isBalanced(TreeNode root) {        if (root==null)            return true;        if (Math.abs(depth(root.left)-depth(root.right))&lt;=1&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right))            return true;        return false;    }    public int depth(TreeNode root){        if (root==null)            return 0;        return Math.max(depth(root.left),depth(root.right))+1;    }}</code></pre><p>上面相当于从根结点往下检查每个节点是否都平衡，会重复求树高，从下往上求就不会重复。</p><p>直接递归到最下面的节点，然后判断节点是否满足平衡条件，设置一个标志，如果有一个不满足平衡条件就将</p><p>标志设为false，并且直接返回，不再进行后面递归的计算。</p><pre><code class="java">class Solution {    private boolean flag = true;    public boolean isBalanced(TreeNode root) {        depth(root);        return flag;    }    public int depth(TreeNode root){        //不符合平衡条件递归直接返回不需要后面的计算        if (!flag)            return 0;        if (root==null)            return 0;        int left=depth(root.left);        int right=depth(root.right);        if (Math.abs(left-right)&gt;1){            flag=false;        }        //当前节点高度        return Math.max(left,right)+1;    }}</code></pre><h2 id="28-合法二叉搜索树"><a href="#28-合法二叉搜索树" class="headerlink" title="28.合法二叉搜索树"></a>28.<a href="https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/" target="_blank" rel="noopener">合法二叉搜索树</a></h2><p><strong>思路：</strong>二叉搜索树特点要么是空树，要么左子树不空，根结点都大于左子树的节点，右子树不空根结点小于右子树节点。左右子树也是二叉排序树，所以只需要中序遍历判断是否是从小到大排列即可。</p><p>有一个测试用例[-2147483648]超过int型长度，所以用long.</p><pre><code class="java">class Solution {    public boolean isValidBST(TreeNode root) {        LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();        helper(list,root);        for (int i=0;i&lt;list.size()-1;i++){            if (list.get(i)&gt;=list.get(i+1))                return false;        }        return true;    }    public void helper(LinkedList&lt;Integer&gt; list, TreeNode root){        if (root ==null)            return;        if (root.left!=null)            helper(list,root.left);        list.add(root.val);        if (root.right!=null)            helper(list,root.right);    }}</code></pre><p><strong>改进：</strong>不需要额外空间存中序遍历结果，只需要在遍历的同时比较前后的值，设置一个全局标志来记录是否符合条件。</p><pre><code class="java">class Solution {    boolean flag = true;    long cur = Long.MIN_VALUE;    public boolean isValidBST(TreeNode root) {        helper(root);        return flag;    }    public void helper(TreeNode root){        if (root ==null)            return;        helper(root.left);        int pre=root.val;        if (cur&lt;pre&amp;&amp;flag)            cur=pre;        else{            flag=false;            return;        }        helper(root.right);    }}</code></pre><p>不用递归，用栈实现中序遍历</p><pre><code class="java">class Solution {    public boolean isValidBST(TreeNode root) {        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();        long pre =Long.MIN_VALUE;        TreeNode cur=root;        while (cur!=null||!stack.isEmpty()){            if (cur!=null){                stack.push(cur);                cur=cur.left;            }else {                cur=stack.pop();                //pre存的是前面的节点值，cur是后面的值，如果是二叉搜索树应该比cur小                if (cur.val&lt;=pre)                    return false;                pre=cur.val;                cur=cur.right;            }        }        return true;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>程序员面试金典6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode5</title>
    <link href="/2020/06/07/LeetCode5/"/>
    <url>/2020/06/07/LeetCode5/</url>
    
    <content type="html"><![CDATA[<h2 id="18-三合一"><a href="#18-三合一" class="headerlink" title="18.三合一"></a>18.<a href="https://leetcode-cn.com/problems/three-in-one-lcci/" target="_blank" rel="noopener">三合一</a></h2><p><strong>思路：</strong>用一个数组表示三个栈，并且<strong>栈需要一个栈顶指针，用来判断是否栈满，能否压栈弹栈</strong>。可以将数组空间设为3+3stackSize分四段，第一段下标0-2对应stackNum，表示三个数组当前存数据长度，第二段表示第一个栈下标3-2+stackSize，第三段表示第二个栈下标3+stackSize-2+2stackSize,第三个栈下标3+2stackSize-2+3stackSize。<strong>栈下标开始通式3+stackNum*stackSize</strong>，<strong>stack[stack[stackNum]+3+stackNum*stackSize]表示当前栈的栈顶的下一个操作位置。</strong></p><pre><code class="java">class TripleInOne {    private int[]stack;    private int stackSize;    public TripleInOne(int stackSize) {        this.stackSize=stackSize;        stack = new int[3+3*stackSize];    }    public void push(int stackNum, int value) {        if (stack[stackNum]&gt;=stackSize)            return;        stack[stack[stackNum]+3+stackNum*stackSize]=value;        stack[stackNum]++;        return;    }    public int pop(int stackNum) {        if (stack[stackNum]==0)            return -1;        stack[stackNum]--;        return stack[stack[stackNum]+3+stackNum*stackSize];    }    public int peek(int stackNum) {        if (stack[stackNum]==0)            return -1;        return stack[stack[stackNum]-1+3+stackNum*stackSize];    }    public boolean isEmpty(int stackNum) {        if (stack[stackNum]==0)            return true;        return false;    }}</code></pre><p>将重复计算写成方法，提高效率。</p><pre><code class="java">class TripleInOne {    private int[]stack;    private int stackSize;    public TripleInOne(int stackSize) {        this.stackSize=stackSize;        stack = new int[3+3*stackSize];    }    public int len(int stackNum,int stackSize){        int l = stack[stackNum]+3+stackNum*stackSize;        return l;    }    public void push(int stackNum, int value) {        if (stack[stackNum]&gt;=stackSize)            return;        stack[len(stackNum,stackSize)]=value;        stack[stackNum]++;        return;    }    public int pop(int stackNum) {        if (stack[stackNum]==0)            return -1;        stack[stackNum]--;        return stack[len(stackNum,stackSize)];    }    public int peek(int stackNum) {        if (stack[stackNum]==0)            return -1;        return stack[len(stackNum,stackSize)-1];    }    public boolean isEmpty(int stackNum) {        if (stack[stackNum]==0)            return true;        return false;    }}</code></pre><h2 id="19-栈的最小值"><a href="#19-栈的最小值" class="headerlink" title="19.栈的最小值"></a>19.<a href="https://leetcode-cn.com/problems/min-stack-lcci/" target="_blank" rel="noopener">栈的最小值</a></h2><p><strong>思路：</strong>用一个栈的栈顶来表示当前最小值。如果x比栈顶小则压入x，否则则再一次压入栈顶元素。出栈两个栈同步出就可以。</p><pre><code class="java">class MinStack {    private Stack&lt;Integer&gt; stack ;    private Stack&lt;Integer&gt; minstack;    /** initialize your data structure here. */    public MinStack() {        stack =new Stack&lt;&gt;();        minstack = new Stack&lt;&gt;();    }    public void push(int x) {        stack.push(x);        if (minstack.size()&lt;1){            minstack.push(x);        }else{            if (x&lt;minstack.peek()){                minstack.push(x);            }else                minstack.push(minstack.peek());        }    }    public void pop() {        stack.pop();        minstack.pop();    }    public int top() {        return stack.peek();    }    public int getMin() {        return minstack.peek();    }}</code></pre><p>可以用链表来存最小值会快一点，思路和上面一样。</p><pre><code class="java">class MinStack {    class Node {        int val;        int min;        Node next;        public Node(int val, int min) {            this.val = val;            this.min = min;        }        public Node(int val, int min, Node next) {            this.val = val;            this.min = min;            this.next = next;        }    }    private Node head = null;    /** initialize your data structure here. */    public MinStack() {    }    public void push(int x) {        if (head == null)             head = new Node(x, x);        else {            int min = Math.min(x, head.min);            Node node = new Node(x, min, head);            head = node;        }    }    public void pop() {        if (head == null)             return;        head = head.next;    }    public int top() {        return head.val;    }    public int getMin() {        return head.min;    }}</code></pre><h2 id="20-堆盘子"><a href="#20-堆盘子" class="headerlink" title="20.堆盘子"></a>20.<a href="https://leetcode-cn.com/problems/stack-of-plates-lcci/" target="_blank" rel="noopener">堆盘子</a></h2><p><strong>思路：</strong>每个栈的大小为cap，超过容量则新建一个栈。需要用一个额外空间维护栈的索引，用来找到指定索引的栈进行出栈，当一个栈元素都出栈完，则需要删除该栈的索引，并且后面的索引前移补上。</p><p>长度不确定需要做到动态添加，找到指定索引的元素并删除，可以用的数据结构有<strong>栈，ArrayList等</strong></p><pre><code class="java">class StackOfPlates {    private Stack&lt;Stack&lt;Integer&gt;&gt; stacks ;    private int cap;    private Stack&lt;Integer&gt; stack;//放在方法外可以提高效率    public StackOfPlates(int cap) {        this.cap=cap;        stacks = new Stack&lt;&gt;();    }    public void push(int val) {        if (cap==0)            return;        if (stacks.size()==0||stacks.peek().size()==cap){             stack =new Stack&lt;&gt;();            stack.push(val);            stacks.push(stack);        }else{            //没有超过容量，在stacks栈顶的栈进行压栈            stacks.peek().push(val);        }    }    //stacks栈顶栈出栈    public int pop() {        if (stacks.size()==0)            return -1;        //先将栈顶元素出栈，如果出栈完栈空了需要在stacks中删除该栈。        int a =stacks.peek().pop();        if (stacks.peek().size()==0){            stacks.pop();        }        return a;    }    public int popAt(int index) {        //注意判断index的合法性        if (index&gt;=stacks.size()||stacks.size()==0){            return -1;        }        //先将指定索引位置栈的栈顶元素出栈，再判断栈是否为空，空则用栈的remove()方法删除，后面索引会前移        int l=stacks.get(index).pop();        if (stacks.get(index).size()==0){            stacks.remove(index);        }        return l;    }}</code></pre><pre><code class="java">class StackOfPlates {    private ArrayList&lt;Stack&lt;Integer&gt;&gt; stacks;    private int capacity;    public StackOfPlates(int cap) {        this.stacks = new ArrayList&lt;Stack&lt;Integer&gt;&gt;();        this.capacity = cap;    }    public void push(int val) {        if (capacity &lt;= 0)            return;        Stack last = getLastStack();        if (last != null &amp;&amp; last.size() &lt; capacity) {            last.push(val);        } else {            Stack&lt;Integer&gt; newStack = new Stack&lt;Integer&gt;();            newStack.push(val);            stacks.add(newStack);        }    }    public int pop() {        return popAt(stacks.size() - 1);    }    public int popAt(int index) {        if (index &lt; 0 || index &gt;= stacks.size()) {            return -1;        }        Stack&lt;Integer&gt; stack = stacks.get(index);        if (stack.size() == 0)            return -1;        int val = stack.pop();        if (stack.size() == 0) {            stacks.remove(index);        }        return val;    }    public Stack getLastStack() {        if (stacks.size() == 0)            return null;        return stacks.get(stacks.size() - 1);    }</code></pre><h2 id="21-化栈为队"><a href="#21-化栈为队" class="headerlink" title="21.化栈为队"></a>21.<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/" target="_blank" rel="noopener">化栈为队</a></h2><p><strong>思路：</strong>一个栈进数据，然后将压栈的栈压入第二个栈实现队列先进先出。</p><pre><code class="java">class MyQueue {    Stack&lt;Integer&gt; stack1 ;    Stack&lt;Integer&gt; stack2 ;    /** Initialize your data structure here. */    public MyQueue() {        stack1 = new Stack&lt;&gt;();        stack2 = new Stack&lt;&gt;();    }    /** Push element x to the back of queue. */    public void push(int x) {        stack1.push(x);    }    /** Removes the element from in front of queue and returns that element. */    public int pop() {        peek();        return stack2.pop();    }    /** Get the front element. */    public int peek() {        if (empty())            return -1;        //stack2为空时才将stack1中元素压过来，因为stack2中元素都比stack1中元素先进入队列。        if (stack2.isEmpty()){            while (!stack1.isEmpty()){                stack2.push(stack1.pop());            }        }        return stack2.peek();    }    /** Returns whether the queue is empty. */    public boolean empty() {        return stack1.isEmpty()&amp;&amp;stack2.isEmpty();    }}</code></pre><h2 id="22-栈排序"><a href="#22-栈排序" class="headerlink" title="22.栈排序"></a><strong>22.<a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/" target="_blank" rel="noopener">栈排序</a></strong></h2><p><strong>思路：</strong>可以用两个栈，在push时候排序，对每一个压入的元素和栈顶比较大小，大于栈顶就将栈顶元素压入另一个栈，然后再比较直到找到第一个比val大的或者栈空，最后将另一个栈中有序的压回当前栈。 </p><pre><code class="java">class SortedStack {    private Stack&lt;Integer&gt;stack1 ;    private Stack&lt;Integer&gt;stack2 ;    public SortedStack() {        stack1=new Stack&lt;&gt;();        stack2=new Stack&lt;&gt;();    }    public void push(int val) {        if (stack1.isEmpty()){            stack1.push(val);            return;        }        //!stack1.isEmpty()&amp;&amp;stack1.peek()&lt;val不可以颠倒        while (!stack1.isEmpty()&amp;&amp;stack1.peek()&lt;val){            stack2.push(stack1.pop());        }        stack1.push(val);        while (!stack2.isEmpty()){            stack1.push(stack2.pop());        }    }    public void pop() {        if (stack1.isEmpty())            return;        stack1.pop();    }    public int peek() {        if (stack1.isEmpty())            return -1;        return stack1.peek();    }    public boolean isEmpty() {        return stack1.isEmpty();    }}</code></pre><p>优化前200ms，优化后17ms.</p><p>优化：优化前是找到当前元素位置然后就将辅助栈元素全压回主栈，这样如果下一个操作还是push，则需要比较次数增多，可以将全压回主栈的工作在pop和peek再操作，这样可以节省push比较的时间。</p><pre><code class="java">class SortedStack {    private Stack&lt;Integer&gt;stack1 ;    private Stack&lt;Integer&gt;stack2 ;    public SortedStack() {        stack1=new Stack&lt;&gt;();        stack2=new Stack&lt;&gt;();    }    public void push(int val) {        if (stack1.empty()) {            stack1.push(val);            return;        }        if (stack1.peek() &lt; val) {            while (!stack1.empty() &amp;&amp; stack1.peek() &lt; val) {                stack2.push(stack1.pop());            }        } else{            while (!stack2.empty() &amp;&amp; stack2.peek() &gt; val) {                stack1.push(stack2.pop());            }        }        stack1.push(val);    }    public void pop() {        while (!stack2.empty()){            stack1.push(stack2.pop());        }        if (stack1.empty()) {            return;        }        stack1.pop();    }    public int peek() {        while (!stack2.empty()){            stack1.push(stack2.pop());        }        if (stack1.empty())            return -1;        return stack1.peek();    }    public boolean isEmpty() {        return stack1.empty();    }}</code></pre><h2 id="23-动物收容所"><a href="#23-动物收容所" class="headerlink" title="23.动物收容所"></a>23.<a href="https://leetcode-cn.com/problems/animal-shelter-lcci/" target="_blank" rel="noopener">动物收容所</a></h2><p><strong>思路：</strong>需要一个数据结构可以存动物信息数组，并可以实现查找和删除任意位置元素的功能，可以用链表实现</p><pre><code class="java">class AnimalShelf {    private List&lt;int[]&gt; linkedList ;    private int[] a ={-1,-1};    public AnimalShelf() {        linkedList=new LinkedList&lt;&gt;();    }    public void enqueue(int[] animal) {        linkedList.add(animal);    }    public int[] dequeueAny() {        if (linkedList.size()==0)            return a;        return linkedList.poll();    }    public int[] dequeueDog() {        //先判断链表是否为空可以提高效率，虽然这个if可省        if (linkedList.size()==0)            return a;        for (int i=0;i&lt;linkedList.size();i++){            //linkedList.get(i)返回的是一个数组            if (linkedList.get(i)[1]==1){                int[]b = linkedList.get(i);                linkedList.remove(i);                return b ;            }        }        return a;    }    public int[] dequeueCat() {        if (linkedList.size()==0)            return a;        for (int i=0;i&lt;linkedList.size();i++){            if (linkedList.get(i)[1]==0){                int[]b =linkedList.get(i);                linkedList.remove(i);                return b;            }        }        return a;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>程序员面试金典6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode4</title>
    <link href="/2020/06/04/LeetCode4/"/>
    <url>/2020/06/04/LeetCode4/</url>
    
    <content type="html"><![CDATA[<h2 id="14-链表求和"><a href="#14-链表求和" class="headerlink" title="14.链表求和"></a>14.<a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">链表求和</a></h2><p><strong>思路：</strong>先将两个链表转成整数，然后相加再转成链表。这种方法过不了，因为链表可能非常长，超过类型能表示的长度。</p><p>两个链表对应位置相加，模10取余新建节点尾插，进位加到下一组。有两种情况：</p><p>​    1.两个链表长度相同，需要判断是否最后进位了，进位了需要创建值为1的新节点</p><p>​    2.两个链表长度不同，也需要判断最后是否进位了，添加节点。</p><p>这两种情况在最后两个链表都读到结尾处，进行一次判断添加就可以了。</p><pre><code class="java">class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        int sum=0;        //a表示两个数相加进位的部分，只能是0或1        int a=0;        ListNode node = new ListNode(-1);        ListNode q=node;        while (l1!=null&amp;&amp;l2!=null){            sum=l1.val+l2.val;            ListNode p = new ListNode((sum+a)%10);            a=(sum+a)/10;            q.next=p;            q=p;            l1=l1.next;            l2=l2.next;        }        while (l1!=null){            //l1.val最大9，a1或0，所以相加有可能进位            ListNode p = new ListNode((l1.val+a)%10);            a=(l1.val+a)/10;            q.next=p;            q=p;            l1=l1.next;        }        while (l2!=null){            ListNode p = new ListNode((l2.val+a)%10);            a=(l2.val+a)/10;            q.next=p;            q=p;            l2=l2.next;        }        //如果两个链表长度相同且最后两个和进位不为0，添加进位为新节点。        if (a!=0){            ListNode p = new ListNode(a);            q.next=p;            q=p;        }        q.next=null;        return node.next;    }}</code></pre><p>递归：</p><pre><code class="java">class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        return add(l1,l2,0);    }    ListNode add(ListNode l1,ListNode l2,int rabit){        //循环结束条件是链表都读完，且没有进位。        if(l1==null &amp;&amp; l2==null &amp;&amp; rabit==0) return null;        if(l1==null &amp;&amp; l2==null &amp;&amp; rabit&gt;0) return new ListNode(rabit);        int num1 =0,num2=0;        if(l1!=null){            num1 = l1.val;        }        if(l2!=null){            num2 = l2.val;        }        int num = (num1+num2+rabit)%10;        rabit  = (num1+num2+rabit)/10;        ListNode node = new ListNode(num);        if(l1!=null){            l1 = l1.next;        }else{            l1 =null;        }        if(l2!=null){            l2 = l2.next;        }else{            l2 = null;        }        ListNode node2 = add(l1,l2,rabit);        node.next = node2;        return node;    }}</code></pre><p>进阶：假设这些数位是正向存放的</p><p>示例：</p><p>输入：(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295<br>       输出：9 -&gt; 1 -&gt; 2，即912</p><p>1.可以把两个链表先头插法转成前面的顺序，按照上面方法做。</p><p>2.也可以用两个栈，或数组存两个链表，再用上面的方法做</p><h2 id="15-回文链表"><a href="#15-回文链表" class="headerlink" title="15.回文链表"></a>15.<a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">回文链表</a></h2><p><strong>思路：</strong>回文特点是中心对称，从前读和从后读一样。新建一个链表头插为链表的反向，然后同步读两个链表比较值。</p><pre><code class="java">class Solution {    public boolean isPalindrome(ListNode head) {        ListNode p = head;        ListNode node = new ListNode(0);        node.next=null;        while (p!=null){            ListNode r = new ListNode(p.val);            r.next=node.next;            node.next=r;            p=p.next;        }        node=node.next;        while (node!=null){            if (node.val!=head.val)                return false;            head=head.next;            node=node.next;        }        return true;    }}</code></pre><ul><li>栈：可以使序列反向</li></ul><pre><code class="java">class Solution {    public boolean isPalindrome(ListNode head) {        ListNode p = head;        Stack&lt;Integer&gt; stack =  new Stack&lt;Integer&gt;();        while (p!=null){            stack.push(p.val);            p=p.next;        }        while (!stack.empty()){            if (stack.pop()!=head.val)                return false;            head=head.next;        }        return true;    }}</code></pre><ul><li><p>可以先遍历出链表长度，然后将前一半头插到新链表，然后和后一半比较。</p></li><li><p>最优解：<strong>快慢指针</strong>遍历找到中点，然后将后半部分或前部分翻转，进行比较。</p><p>O(n) 时间复杂度和 O(1) 空间复杂度</p></li></ul><pre><code class="java">class Solution {    public boolean isPalindrome(ListNode head) {        //快指针p一次读两个，慢指针q一次读一个        ListNode p = head;        ListNode q = head;        ListNode r = null;        ListNode t = null;        while (p!=null&amp;&amp;p.next!=null){            p=p.next.next;            r=q;            q=q.next;            //头插前半部分            r.next=t;            t=r;        }        //p每次读两个，如果链表为奇数，则p指向最后一个位置，q指向最中间的位置。        //如果链表为偶数，则p指向null,q指向后半部分第一个。        if (p!=null){            //从后半部分第一个开始比较，第一种情况需要将q后移一位。            q=q.next;        }        while (q!=null){            if (q.val!=t.val)                return false;            else {                q=q.next;                t=t.next;            }        }        return true;    }}</code></pre><h2 id="16-链表相交"><a href="#16-链表相交" class="headerlink" title="16.链表相交"></a>16.<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">链表相交</a></h2><p>思路：两个链表相交特点是有指针相同，且相同节点之后节点都相同，但两个链表不一定相等，所以不能对应去比较。可以让两个链表遍历完再回到对方的头节点遍历，此时会出现长链表刚回到头节点，短链表已经读到头节点后几个了。此时后短链表距离头节点的距离就是相交链表的不想交部分的差值。现在可以将两个链表同时遍历并对应比较，第一次相同的位置就是相交点。</p><p>短链长度=不相交部分a+相交长度c</p><p>长链长度=不相交部分b+相交c</p><p>两个链表都走了a+b+c然后相交。</p><p><strong>总结就是找两个链表不想交部分的长度差值，然后长的链表先遍历这个差值长度，然后同步遍历比较。否则需要O(M*N)复杂度。因此第二种方法也可以先各自遍历求长度差</strong>。</p><pre><code class="java">public class Solution {    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {        ListNode p = headA;        ListNode q = headB;        while (p != q) {            p = p == null ? headB : p.next;            q = q == null ? headA : q.next;        }        return p;    }}</code></pre><pre><code class="java">public class Solution {    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {        ListNode p = headA;        ListNode q = headB;        int l1 = 0, l2 = 0;        while (p != null) {            p = p.next;            l1++;        }        while (q != null) {            q = q.next;            l2++;        }        int l = Math.abs(l1 - l2);        for (int i = 0; i &lt; l; i++) {            if (l1 &gt; l2) {                headA = headA.next;            } else                headB = headB.next;        }        while (headA != headB) {            headA = headA.next;            headB = headB.next;        }        return headA;    }}</code></pre><h2 id="17-环路检测"><a href="#17-环路检测" class="headerlink" title="17.环路检测"></a>17.<a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">环路检测</a></h2><p><strong>思路：</strong>快慢指针，如果有环两个指针一定会相遇。</p><p><img src="2020-06-04-LeetCode4/%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B.png" srcset="/img/loading.gif" alt=""></p><p>设慢指针走到相遇点走了a+b+nc,快指针走了a+b+mc,而快指针路程是慢指针两倍2a+2b+2nc</p><p>所以可以得出 a+b+mc=2a+2b+2nc。整理得a=(m-2n）c-b。</p><p>也就是说如果一个指针现在从头出发走到入环点，走了a，另一个指针从相遇点走了m-2n圈c，回到了相遇点再后退b，就会在入环点和a相遇。</p><p><strong>总结：一个指针从头出发一个指针从快慢指针相遇点出发，必会相遇在入环。所以任务变成先找相遇点，再找入环点。</strong></p><pre><code class="java">public class Solution {    public ListNode detectCycle(ListNode head) {        ListNode p = head;        ListNode q = head;        while (q!=null&amp;&amp;q.next!=null){            p=p.next;            q=q.next.next;            if (p==q){                q=head;                while (p!=q){                    q=q.next;                    p=p.next;                }                return p;            }        }        return null;    }}</code></pre><ul><li>HashSet判指针重</li></ul><pre><code class="java">public class Solution {    public ListNode detectCycle(ListNode head) {        ListNode p = head;        HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;();        while (p!=null){            if (!set.contains(p)){                set.add(p);                p=p.next;            }else                return p;        }        return null;    }}</code></pre><p>超时的两种想法：</p><ul><li>每次断开一个节点，如果是环开头节点则从后面继续读还会读到，重复读到断开节点的下一个节点则说明断开节点不是环开头，此时应该把断开节点再连上，开始测试下一个。</li></ul><pre><code class="java">public class Solution {    public ListNode detectCycle(ListNode head) {        if (head == null)            return head;        ListNode p = head;        ListNode q = p.next;        ListNode r = p.next;        while (true){            p.next=null;            if (r==p){                p.next = q;                //System.out.println(p.val);                return p;            }            if (r==null){                p.next = q;                //System.out.println(r.val);                return r;            }            r=r.next;            if (r==q){                p.next=q;                p=q;                q=p.next;                r=p.next;            }        }    }}</code></pre><p>回环法：把每个节点的next指向自己，直到环开头已经指向自己了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>程序员面试金典6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode3</title>
    <link href="/2020/05/29/LeetCode3/"/>
    <url>/2020/05/29/LeetCode3/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="10-移除重复节点"><a href="#10-移除重复节点" class="headerlink" title="10.移除重复节点"></a>10.<a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">移除重复节点</a></h2><p><strong>思路：</strong> 双指针，q将所有与当前p相同的断链，p保持不同的链接。</p><pre><code class="java">class Solution {    public ListNode removeDuplicateNodes(ListNode head) {        ListNode p = head;        while (p!=null){            ListNode q=p;            while (q.next!=null){                if (q.next.val==p.val)                    q.next=q.next.next;                else                    q=q.next;            }            p=p.next;        }        return head;    }}</code></pre><p>也可以消耗额外空间判重比如用HashSet、布尔数组</p><pre><code class="java">class Solution {    public ListNode removeDuplicateNodes(ListNode head) {        if (head==null)            return null;        ListNode pre =head;        ListNode next=head;        Set set = new HashSet();        set.add(pre.val);        while (pre.next!=null){            next=pre.next;            if (set.contains(next.val)){                pre.next=next.next;            }else{                set.add(next.val);                pre=next;            }                    }        return head;    }}</code></pre><h2 id="11-返回倒数第-k-个节点"><a href="#11-返回倒数第-k-个节点" class="headerlink" title="11.返回倒数第 k 个节点"></a>11.<a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">返回倒数第 k 个节点</a></h2><p><strong>思路：</strong>可以先得到链表长度l，然后从头读返回第l-k+1值</p><pre><code class="java">class Solution {    public int kthToLast(ListNode head, int k) {        ListNode p = head;        int i=0;        while (p!=null){            i++;            p=p.next;        }        p=head;        for (int j=1;j&lt;i-k+1;j++){            p=p.next;        }        return p.val;    }}</code></pre><p>双指针游走：两个指针p、q先都指向head,然后q先向后移动k下保证p、q现在间隔k，然后同步位移p、q，当q读到null时，p则指向倒数第k个节点。</p><pre><code class="java">class Solution {    public int kthToLast(ListNode head, int k) {        ListNode p = head;        ListNode q = head;        for (int i=0;i&lt;k;i++){            q=q.next;        }        while (q!=null){            q=q.next;            p=p.next;        }        return p.val;    }}</code></pre><h2 id="12-删除中间节点"><a href="#12-删除中间节点" class="headerlink" title="12.删除中间节点"></a>12.<a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank" rel="noopener">删除中间节点</a></h2><p><strong>思路：</strong>由于单向链表无法表示前面节点，所以不能直接将指定节点断链，可以考虑将后面的值依次往前提一个位置，最后一个节点需要抛弃断开。</p><pre><code class="java">class Solution {    public void deleteNode(ListNode node) {        ListNode p = node.next;        while (p.next!=null){            node.val=p.val;            node = p;            p=p.next;        }        node.val=p.val;        node.next=null;    }}</code></pre><p><strong>删除一个节点：只需要将下个节点的值复制到当前节点，然后删除下一个节点就可以了。有种脑筋急转弯的感觉(・ω・｀;),一个一个移是真的蠢。</strong></p><pre><code class="java">class Solution {    public void deleteNode(ListNode node) {        node.val=node.next.val;        node.next=node.next.next;    }}</code></pre><h2 id="13-分割链表"><a href="#13-分割链表" class="headerlink" title="13.分割链表"></a>13.<a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener">分割链表</a></h2><p>思路：这题目，读了好几遍也没看懂这个示例为什么是这个输出？暂且理解为顺序遍历只要找到比基准小的就和第一个大于或等于基准的交换。<strong>测试一个用例输出不一样，提交居然通过了！！！！所以这个输出不唯一，只要满足上面条件就可以？</strong>莫名其妙。</p><pre><code class="java">class Solution {    public ListNode partition(ListNode head, int x) {        ListNode p = head;        ListNode pre = p;        int t =0;        while (p!=null){            if (p.val&lt;x){                t=pre.val;                pre.val=p.val;                p.val=t;                pre=pre.next;            }            p=p.next;        }        return head;    }}</code></pre><p>经过几次尝试终于可能理解了，力扣的示例有问题，</p><p>测试用例:[3,5,8,5,10,2,1] x=5</p><p>期望结果其实应该是[1,2,3,10,5,8,5]。</p><p>测试用例:[1,4,3,2,5,2] x=3</p><p>期望结果是[2,2,1,5,3,4]。</p><p><strong>规律是，顺序遍历，小于x的就放到链表的最前面，大于等于x的放在第一个大于小于x的前面。</strong></p><p>以[3,5,8,5,10,2,1] x=5为例，过程是：</p><p>3<strong>–</strong>35<strong>–</strong>385<strong>–</strong>3585<strong>–</strong>310585<strong>–</strong>2310585<strong>–</strong>12310585</p><pre><code class="java">class Solution {    public ListNode partition(ListNode head, int x) {        if (head==null||head.next==null)           return head;        ListNode p = head.next;        ListNode q = p.next;        ListNode node=new ListNode(-1);        node.next=head;        head.next=null;        //对于第二个节点，只有当head.val&lt;x&amp;&amp;p.val&gt;=x时才放到head后面，        // 其他三种情况都是放到head前面。        if (head.val&lt;x&amp;&amp;p.val&gt;=x){            p.next=head.next;            head.next=p;        }else {            p.next=node.next;            node.next=p;        }        while (q!=null){            p=q;            q=q.next;            //比x小就头插到node后，大于等于x就头插到head后            if (p.val&lt;x){                p.next=node.next;                node.next=p;            }else {                p.next=head.next;                head.next=p;            }        }        return node.next;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>程序员面试金典6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode2</title>
    <link href="/2020/05/28/LeetCode2/"/>
    <url>/2020/05/28/LeetCode2/</url>
    
    <content type="html"><![CDATA[<h2 id="6-字符串压缩"><a href="#6-字符串压缩" class="headerlink" title="6.字符串压缩"></a>6.<a href="https://leetcode-cn.com/problems/compress-string-lcci/" target="_blank" rel="noopener">字符串压缩</a></h2><p><strong>思路：</strong>可以用数组存压缩后的字符串，遍历比较相邻的字符，相同则计数器加1，不同则将当前计数器存到数组，继续比较下一个。</p><p>StringBuilder: 前后两个比较，相同则加1</p><pre><code class="java">class Solution {    public String compressString(String S) {        //如果长度为1或空肯定返回原字符串        if (S.length()&lt;=1)            return S;        StringBuilder sb = new StringBuilder().append(S.charAt(0));        int j=1;        for (int i=1;i&lt;S.length();i++){            if (S.charAt(i)==S.charAt(i-1))                j++;            else{                sb.append(j).append(S.charAt(i));                j=1;            }        }        return sb.append(j).length()&lt;S.length()?sb.toString():S;    }}</code></pre><p>双指针 找到每个字符之后第一个不相同的位置，一次性计数j-i</p><pre><code class="java">class Solution {    public String compressString(String S){            int N=S.length();            int i=0;            StringBuilder sb=new StringBuilder();            while(i&lt;N){            int j=i;            while(j&lt;N &amp;&amp;S.charAt(j)==S.charAt(i)){            j++;            }            sb.append(S.charAt(i));            sb.append(j-i);            i=j;            }        return sb.length()&lt;S.length()?sb.toString():S;    }}</code></pre><h2 id="7-旋转矩阵"><a href="#7-旋转矩阵" class="headerlink" title="7.旋转矩阵"></a>7.<a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">旋转矩阵</a></h2><p><strong>思路：</strong>这种题通常可以找到下标的规律。只要观察原下标的位置换成了什么下标就可以发现，原下标(i,j)换成了(n-1-j,i),并且换到了(j,n-1-i)的位置上，四个位置的元素满足这个交换规律为一组，所以只需要遍历n<em>n/4个元素进行交换就可以了，以4-4矩阵为例，下标位置为 *</em>，**标的位置</p><p>，。。。</p><p>，，。。</p><p>，。。。</p><p>。。。。</p><pre><code class="java">class Solution {    public void rotate(int[][] matrix) {        int l=matrix.length;        for (int i=0;i&lt;l-1;i++){            for (int j=0;j&lt;=i&amp;&amp;j&lt;l-1-i;j++){                int t=matrix[i][j];                matrix[i][j]=matrix[l-1-j][i];                matrix[l-1-j][i]=matrix[l-1-i][l-1-j];                matrix[l-1-i][l-1-j]=matrix[j][l-1-i];                matrix[j][l-1-i]=t;            }        }    }}</code></pre><ul><li>换两次，先转置再中线对换</li></ul><p>原矩阵为：<br>[1,2,3]<br>[4,5,6]<br>[7,8,9]</p><p>转置之后，即按斜对角线进行数据交换后的结果为：<br>[1,4,7]<br>[2,5,8]<br>[3,6,9]</p><p>矩阵再根据中间列进行对折，即中间列两边元素进行交换，得到：<br>[7,4,1]<br>[8,5,2]<br>[9,6,3]</p><pre><code class="java">class Solution {    public void rotate(int[][] matrix) {        int n = matrix.length;        //矩阵转置，即按斜对角线进行数据交换        for(int i=0;i&lt;n;i++){            for(int j=i;j&lt;n;j++){                int temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            }        }        //矩阵根据中间列进行对折，得到最终结果        for(int i=0;i&lt;n;i++){            for(int j=0;j&lt;n/2;j++){                int temp = matrix[i][j];                matrix[i][j] = matrix[i][n-j-1];                matrix[i][n-j-1] = temp;            }        }    }}</code></pre><h2 id="8-零矩阵"><a href="#8-零矩阵" class="headerlink" title="8.零矩阵"></a>8.<a href="https://leetcode-cn.com/problems/zero-matrix-lcci/" target="_blank" rel="noopener">零矩阵</a></h2><p><strong>思路：</strong>直接找，找到然后遍历行列设为0肯定复杂度太大。可以第一遍遍历先找到0，然后用两个个集合分别记录下i和j，第二遍遍历再将在记录里的下标设为0。</p><pre><code class="java">class Solution {    public void setZeroes(int[][] matrix) {        int m = matrix.length;        int n = matrix[0].length;        HashSet set1 = new HashSet&lt;&gt;();        //HashSet set2 = new HashSet&lt;&gt;();用一个集合就可以        for (int i=0;i&lt;m;i++){            for (int j=0; j&lt;n;j++){                if (matrix[i][j]==0){                    set1.add(i);                    set1.add(j+m);                }            }        }        for (int i=0;i&lt;m;i++){            for (int j=0;j&lt;n;j++){                if (set1.contains(i)||set1.contains(j+m)){                    matrix[i][j]=0;                }            }        }    }}</code></pre><p>上面方法用集合运行太慢。换成布尔数组快2ms,想法是一样的。</p><pre><code class="java">class Solution {    public void setZeroes(int[][] matrix) {        boolean[] line = new boolean[matrix.length];        boolean[] column = new boolean[matrix[0].length];        // 找出要清零的行列        for (int i = 0; i &lt; matrix.length; i++) {            for (int j = 0; j &lt; matrix[0].length; j++) {                if (matrix[i][j] == 0) {                    line[i] = true;                    column[j] = true;                }            }        }        // 开始对行清零        for (int i = 0; i &lt; matrix.length; i++) {            if (line[i]) {                for (int j = 0; j &lt; matrix[0].length; j++) {                    matrix[i][j] = 0;                }            }        }        // 开始对列清零        for (int i = 0; i &lt; matrix[0].length; i++) {            if (column[i]) {                for (int j = 0; j &lt; matrix.length; j++) {                    matrix[j][i] = 0;                }            }        }    }}</code></pre><ul><li>其他想法：遍历一遍将设0标记在第一行和第一列，然后第一行第一列元素为0 则表示该行/列需要清零。</li></ul><h2 id="9-字符串轮转"><a href="#9-字符串轮转" class="headerlink" title="9.字符串轮转"></a>9.<a href="https://leetcode-cn.com/problems/string-rotation-lcci/" target="_blank" rel="noopener">字符串轮转</a></h2><p><strong>思路：</strong>首先两个字符串长度不同直接返回false，两个都是空串返回true。符合题目特点的s1和s2是每个字符串被分成两个子串，只要这两个子串分别相同则true。遍历s1，找到和s2第一个元素相同的位置，从这个位置分成两个子串分别比较。</p><pre><code class="java">class Solution {    public boolean isFlipedString(String s1, String s2) {        if (s1.length()!=s2.length()) {            return false;        }        if (s1.length()==0)            return true;        int l= s1.length();        for (int i=0;i&lt;l;i++){            if (s1.charAt(i) ==s2.charAt(0)){                if (s1.substring(i,l).equals(s2.substring(0,l-i))&amp;&amp;                    s1.substring(0,i).equals(s2.substring(l-i,l))){                    return true;                }            }        }        return false;    }}</code></pre><ul><li>只调用一次检查子串方法，运行更快：</li></ul><p>将s1与s1拼接成一个新字符串，则如果符合题意，s2必定是新串的子串。</p><pre><code class="java">class Solution {    public boolean isFlipedString(String s1, String s2) {        if (s1.length()!=s2.length())            return false;        return (s1+s1).contains(s2);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>程序员面试金典6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode</title>
    <link href="/2020/05/25/LeetCode/"/>
    <url>/2020/05/25/LeetCode/</url>
    
    <content type="html"><![CDATA[<h1 id="《程序员面试金典6》-java"><a href="#《程序员面试金典6》-java" class="headerlink" title="《程序员面试金典6》(java)"></a>《程序员面试金典6》(java)</h1><h2 id="1-判断字符唯一"><a href="#1-判断字符唯一" class="headerlink" title="1.判断字符唯一"></a><a href="https://leetcode-cn.com/problems/is-unique-lcci/" target="_blank" rel="noopener">1.判断字符唯一</a></h2><p><strong>思路：</strong></p><ul><li><strong>直接用String类的方法，无需额外数据结构</strong></li></ul><p>​    indexOf( ) ，lastIndexOf( )    从第i个字符以后查找i位置字符索引，存在重复则查到索引大于-1，否则返回-1。</p><p>​    replace( )   如果字符唯一则将字符替换成<strong>空串</strong>，字符串长度只减一。</p><pre><code class="java">class Solution {     public boolean isUnique(String astr) {         int l = astr.length();          String temp;          for (int i=0;i&lt;l;i++){              temp=astr;              if ((temp.replace(String.valueOf(temp.charAt(i)),&quot;&quot;)).length()!=l-1)                  return false;          }          return  true;      } }</code></pre><ul><li><p><strong>用额外数据结构</strong></p><p>数组    </p><p>​            1.双循环直接查找。</p><p>​            2.sort后比较相邻位置</p><pre><code class="java">class Solution {    public boolean isUnique(String astr) {        char[] c = astr.toCharArray();        Arrays.sort(c);        for (int i=0;i&lt;c.length-1;i++){            if (c[i]==c[i+1])                return false;        }        return true;    }}</code></pre><p>HashSet  比较集合长度和数组长度是否相等判重</p><pre><code class="java">class Solution {    public boolean isUnique(String astr) {        char[]c = astr.toCharArray();        Set set = new HashSet();        for (char a:c)            set.add(a);        if (set.size()!=c.length)            return false;        return true;    }}</code></pre><p>Bitset  判断该位置有没有元素判重，无则加入</p><pre><code class="java">class Solution {    public boolean isUnique(String astr) {        BitSet set = new BitSet();        for (char a:astr.toCharArray()){            if (set.get(a))                return false;            set.set(a);        }        return true;    }}</code></pre><p>Map  键唯一特点，将字符串每个字符设为键判重</p><pre><code class="java">class Solution {    public boolean isUnique(String astr) {        Map map = new HashMap();        for (char c:astr.toCharArray()){            if (map.containsKey(c))                return false;            map.put(c,0);        }        return true;    }}</code></pre></li></ul><h2 id="2-判定是否互为字符重排"><a href="#2-判定是否互为字符重排" class="headerlink" title="2.判定是否互为字符重排"></a>2.<a href="https://leetcode-cn.com/problems/check-permutation-lcci/" target="_blank" rel="noopener">判定是否互为字符重排</a></h2><p><strong>思路：</strong></p><p>题意即判断两个字符串的字符相同且相同字符数量也相同。</p><ul><li>不用库函数，首先长度相同，运用两个字符数组相同字符数量也相同特点，需要一个额外字符数组长度为128存字符数，遍历两个字符数组的每个字符，对应额外数组的索引位置一个加一个减，最后根据额外字符数组是否都为0判断。</li></ul><ul><li>Map 字符为键，相同字符数量为值，可以用两个map，直接eauqls比较两个map是否相同，也可以一个map一个数组,每次匹配到map值不为0就减一，直到数组比较完，前提是两个字符串长度相同。</li></ul><ul><li>先数组排序然后equals比较是否相同。</li></ul><pre><code class="java">class Solution {    public boolean CheckPermutation(String s1, String s2) {        char[] c1 = s1.toCharArray();        char[] c2 = s2.toCharArray();        Arrays.sort(c1);        Arrays.sort(c2);        return Arrays.equals(c1,c2);    }}</code></pre><ul><li>StringBuilder  可以删除指定位置的值deleteCharAt(int index) ，只要将一个匹配另一个StringBuilder，找不到则返回false，找到则删除，当两个长度相同，直到数组匹配完就返回true。</li></ul><pre><code class="java">class Solution {    public boolean CheckPermutation(String s1, String s2) {        if (s1.length() != s2.length()) {            return false;        }        StringBuilder s = new StringBuilder(s2);        for (int i = 0, length = s1.length(); i &lt; length; i++) {            if (s.indexOf(String.valueOf(s1.charAt(i))) == -1) {                return false;            }            s.deleteCharAt(s.indexOf(String.valueOf(s1.charAt(i))));        }        return true;    }}</code></pre><h2 id="3-URL化"><a href="#3-URL化" class="headerlink" title="3.URL化"></a>3.<a href="https://leetcode-cn.com/problems/string-to-url-lcci/" target="_blank" rel="noopener">URL化</a></h2><p><strong>思路：</strong></p><ul><li>初步想法：遍历字符数组，读到空格在新数组中依次添加三个字符。由于S在length长度之后还可能有空格，所以需要一个控制变量j来控制长度为length。最后新数组由于长度过长后面有很多空字符，转成字符串需要用trim()去掉空格。</li></ul><pre><code class="java">class Solution {    public String replaceSpaces(String S, int length) {        //char[]c = new char[3*length];        char[]c = new char[S.length()];        int i=0,j=0;        for (char s:S.toCharArray()){            if (j&lt;length){                if (s==&#39; &#39;){                    c[i]=&#39;%&#39;;                    c[i+1]=&#39;2&#39;;                    c[i+2]=&#39;0&#39;;                    i+=3;                }else{                    c[i]=s;                    i+=1;                }                j++;            }        }       // String s1=String.valueOf(c);       // return s1.trim();是前后空格都去掉，实际只需要判断后面        //return String.valueOf(c).substring(0,i);        return new String(ans, 0, i);    }}</code></pre><ul><li>直接用库函数替换</li></ul><pre><code class="java">class Solution {    public String replaceSpaces(String S, int length) {        return S.substring(0,length).replaceAll(&quot; &quot;,&quot;%20&quot;);    }}</code></pre><ul><li>Stringbuilder可以直接append字符串</li></ul><pre><code class="java">class Solution {    public String replaceSpaces(String S, int length) {        StringBuilder sb = new StringBuilder();        for (int i=0;i&lt;S.length()&amp;&amp;i&lt;length;i++){            if (S.charAt(i)==&#39; &#39;)                sb.append(&quot;%20&quot;);            else{                sb.append(S.charAt(i));            }        }        return sb.toString();    }}</code></pre><h2 id="4-回文排列"><a href="#4-回文排列" class="headerlink" title="4.回文排列"></a>4.<a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/" target="_blank" rel="noopener">回文排列</a></h2><p><strong>思路：</strong>回文串满足的特点：<strong>最多只能有一个字符数量是奇数</strong>。所以可以统计相同字符数量看奇数的数量是否&lt;=1。</p><pre><code class="java">class Solution {    public boolean canPermutePalindrome(String s) {        int[] ascii = new int[256];        int count = 0;        for(int i = 0;i&lt;s.length();i++){            ascii[s.charAt(i)]++;            if((ascii[s.charAt(i)] &amp; 1) == 1){                count++;            }else{                count--;            }        }        return count &lt;= 1;    }}</code></pre><ul><li>数组先排序，然后两个两个读，相同则继续读，不同则记录k加1，并且再读一个，和前面相同则继续读。记录大于1则false。<strong>需要判断i是否指向了最后一个位置，否则可能数组越界，如果是的话则说明最后一个单着，k+1</strong>。</li></ul><pre><code class="java">class Solution {    public boolean canPermutePalindrome(String s) {        char[]c=s.toCharArray();        int k=0;        Arrays.sort(c);        for (int i=0;i&lt;c.length;i++){            if (i+1&lt;c.length&amp;&amp;c[i]==c[i+1])                i++;            else {                k++;                if (k&gt;1)                    return false;            }        }        return true;    }}</code></pre><ul><li>HashSet 或者栈。遍历字符，检查HashSet，有则删除，没有则添加。最后根据集合大小判断。</li></ul><pre><code class="java">class Solution {    public boolean canPermutePalindrome(String s) {        HashSet hs = new HashSet();        for (char c:s.toCharArray()){            if (hs.contains(c)){                hs.remove(c);            }else{                hs.add(c);            }        }        if (hs.size()&gt;1)            return false;        return  true;    }}</code></pre><h2 id="5-一次编辑"><a href="#5-一次编辑" class="headerlink" title="5.一次编辑"></a>5.<a href="https://leetcode-cn.com/problems/one-away-lcci/" target="_blank" rel="noopener">一次编辑</a></h2><p><strong>思路：</strong>首先根据长度排除所有长度差大于等于2的。然后可以分三种情况再判断</p><p>​            1.如果first.length()+1=second.length()</p><p>​                    则需要判断是否可以添加一个字符。同步遍历比较，当不同时，读second下一个，相同则把记录当前不同的次数变量k++。然后再继续同步遍历，如果再找到不同则返回false；</p><p>​            2.如果first.length()=second.length()</p><p>​                    则需要判断是否替换一个字符。同步遍历比较到不同时，则把记录当前不同的次数变量k++，然后继续遍历，如果再找到不同则返回false；</p><p>​            3.如果first.length()-1=second.length()</p><p>​                    则需要判断是否可以删除一个字符，与第一种情况first和second反过来即可。</p><blockquote><p>改了很久的bug。。。。终于过了!!!!这种朴素的想法真的是漏洞太多了，我太难了。</p><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时 :2 ms, 在所有 Java 提交中击败了99.42%的用户</p><p>内存消耗 :39.6 MB, 在所有 Java 提交中击败了100.00%的用户</p></blockquote><pre><code class="java">class Solution {    public boolean oneEditAway(String first, String second) {        if  (Math.abs(first.length()-second.length())&gt;=2)            return false;        if ((first.length()==0||second.length()==0)&amp;&amp;Math.abs(first.length()-second.length())==1)            return true;        char[] a = first.toCharArray();        char[] b = second.toCharArray();        int k=0;        if (first.length()==second.length()){            for (int i=0;i&lt;first.length();i++){                if (a[i]!=b[i])                    k++;                if (k&gt;1)                    return false;            }        }        else if (first.length()-1==second.length()) {            for (int i = 0, j = 0; i &lt; first.length(); i++, j++) {                if (k &lt; 1 &amp;&amp; a[i] != b[j] &amp;&amp; a[i + 1] == b[j]) {                    k++;                    i++;                } else if (a[i] == b[j]&amp;&amp;j&lt;second.length()-1){                }else if (a[i] == b[j]&amp;&amp;j==second.length()-1){                    break;                }                else {                    return false;                }            }        }        else{            for (int i = 0, j = 0; i &lt; second.length(); i++, j++) {                if (k &lt; 1 &amp;&amp; b[i] != a[j] &amp;&amp; b[i + 1] == a[j]) {                    k++;                    i++;                } else if (b[i]==a[j]&amp;&amp;j&lt;first.length()-1){                }else if (b[i]==a[j]&amp;&amp;j==first.length()-1)                    break;                else {                    return false;                }            }        }        return true;    }}</code></pre><ul><li>优化代码：可以通过将两个串长的那个一直用变量first表示，短的用second表示，这样可以将第一种和第三种情况合并。</li></ul><pre><code class="java">class Solution {    public boolean oneEditAway(String first, String second) {        //小的字符串用second，大的first        if(first.length() &gt; second.length()){            String temp = first;            first = second;            second = temp;        }        if(second.length()-first.length()&gt;1){            return false;        }else {            if(second.length() == first.length()){                //判断是否可以替换,两处相同位置不同就return false                int count = 0;                for (int i = 0; i &lt;first.length() ; i++) {                    if(first.charAt(i) != second.charAt(i)){                        count++;                        if(count == 2){                            return false;                        }                    }                }            }else {                //判断是否通过加就行                for (int i = 0; i &lt;first.length() ; i++) {                    if(first.charAt(i)!=second.charAt(i) &amp;&amp; first.charAt(i) !=second.charAt(i+1)){                        return false;                    }                }            }        }        return true;    }}</code></pre><p>定位到第一个不同的地方，然后比较子串是否相同。将长度相同和差一这两种情况通过改变比较子串的开始位置来当成整体实现。</p><pre><code class="java">class Solution {    public boolean oneEditAway(String first, String second) {        if (first == null || second == null) return false;        int len1 = first.length();        int len2 = second.length();        if (Math.abs(len1 - len2) &gt; 1) return false;        if (len2 &gt; len1) return oneEditAway(second, first);        for (int i = 0; i &lt; len2; i++){            if (first.charAt(i) != second.charAt(i)){                // 如果是长度相同字符串，那就比较下一个，如果长度不一样，那就从该字符开始进行比较。                return first.substring(i + 1).equals(second.substring(len1 == len2 ? i + 1 : i));            }        }        return true;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>程序员面试金典6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>疫情期间</title>
    <link href="/2020/05/08/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4/"/>
    <url>/2020/05/08/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="理直气壮做宅男的日子"><a href="#理直气壮做宅男的日子" class="headerlink" title="理直气壮做宅男的日子"></a>理直气壮做宅男的日子</h1><img src="6.jpeg" srcset="/img/loading.gif" style="zoom:80%;" /><p>​    </p><p>这个寒假注定是印象深刻的。</p><p>​    当初放假打包想着精简行李的时候一定不会想到，此刻的我会为没有衣服穿而发愁。毕竟已经立夏了，我躺在床上，望着仅带的两件冬装，悔不当初。这只是这次疫情影响得很小的一个方面，更广泛的涉及到了生活方式、学习进度、精神层面以及人生方向。</p><ul><li><p><strong>生活方式</strong></p><blockquote><p>这是最直观的一个方面。本来便属于那种除了旅行和吃喝，不太愿意出去的人，这次疫情为了响应国家号召，理所当然的挖掘出百分百宅男属性，游戏、外卖、床三位一体，获得成就一个月不下楼，一个半月不理发与不刮胡子。由于没有束缚，作息也从11-7调到了3-11，获得和平精英荣耀皇冠，云顶之弈白金成就。<strong><em>枯燥</em></strong>。</p><p>最近意识到这种生活方式是非常不负责的，正在积极调整。发誓不熬没有意义的夜，不关心与我无关的事，将精力集中在需要的地方。待陌上花开，可缓缓归矣。</p><img src="4.jpg" srcset="/img/loading.gif" style="zoom: 80%;" /><center>鸭绿江边骑行</center></blockquote></li><li><p><strong>学习进度</strong></p><blockquote><p>这是最惭愧的一个方面。三个月来，学习效率很低，计划容易被琐事打断，吉他还在坚持，虽然收效甚微，但逐渐意识到所有能力几乎都逃不过熟能生巧。自认为之前前进的动力大多来自外部的压力，这种是非常不稳定也不健康的，当对外界充耳不闻时便容易活在自我满足的状态中，这有清朝的前例在，是需要总结和改正的，下一步应该把内在的需求转化为学习的动力源泉，站得越高的人越是向上看的，所以要形成这种良性的内在循环促进提高。</p><p><img src="3.jpg" srcset="/img/loading.gif" style="zoom:80%;" /><img src="5.jpg" srcset="/img/loading.gif" style="zoom:80%;" /></p><center>幼稚->成熟</center><img src="2.jpg" srcset="/img/loading.gif" style="zoom: 80%;" /><center>只有打开软件才会想起来把时间都丢去哪了</center>    </blockquote></li><li><p><strong>精神层面</strong></p><blockquote><p>这是最隐晦的一个方面。就算想得到也是不容易说清楚的。从每天醒来一睁眼就打开手机看昨天的增长人数，到后来的不再刻意关心的麻木。从每天期待各种有价值的新闻去抒发态度，到将新闻软件都卸载。从《后浪》到《非浪》。这三个月应该是我最悠闲的去思考一些东西的时光了。杨绛先生说过：你的主要的问题在于读书不多而想的太多。不得不说，先生的眼光还是准确。我的确就是这样，读书不多却总爱想入非非，也没有个拿得出手的结论。我是一个喜欢和别人争论对错，想要说服别人的人，这点可以说是偏执，在以往的生活中也容易碰壁，希望今后可以多吸收，少输出。</p></blockquote></li></ul><ul><li><p><strong>人生方向</strong></p><blockquote><p>这是最纠结的一个方面。可以说现在还在纠结，可能会一直下去。但我并不认为这样不好，人生就是充满可能性的，每一个阶段所朝的方向也只是这个阶段所拥有的，我不愿意没有纠结过就放弃任意一种可能，但对每个阶段的目标我都希望奔跑前进。最近放弃了做游戏和搞前端的想法，但可能只是近两年的放弃。也放弃了春招，选择了继续学习。如果可以，就人生而言，我希望我在做不规则运动，我不嫉妒直线的快速到达，也不羡慕曲线的平滑过渡。带着好奇和随性来摸索，即便没有归属也没有关系，只因我的眼想要看的更远，我的心可以容纳更多。</p></blockquote><blockquote><p><img src="1.jpg" srcset="/img/loading.gif" alt=""></p><center>窗外的火烧云</center></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2020</tag>
      
      <tag>总结</tag>
      
      <tag>宅</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年计划</title>
    <link href="/2020/04/17/2020%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    <url>/2020/04/17/2020%E5%B9%B4%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="PLAN"><a href="#PLAN" class="headerlink" title="PLAN"></a>PLAN</h1><img src="0.jpg" srcset="/img/loading.gif" style="zoom:200%;" /><ul><li><strong>吉他</strong></li><li><strong>30本书</strong></li><li><strong>秋招</strong></li><li><strong>去三个陌生的城市</strong></li><li><strong>坚持写博客</strong></li><li><strong>记账</strong></li><li><strong>论文</strong></li><li><strong>未完待续……</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>2020</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
