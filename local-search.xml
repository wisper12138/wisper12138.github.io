<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode</title>
    <link href="/2020/05/25/LeetCode/"/>
    <url>/2020/05/25/LeetCode/</url>
    
    <content type="html"><![CDATA[<h1 id="《程序员面试金典6》-java"><a href="#《程序员面试金典6》-java" class="headerlink" title="《程序员面试金典6》(java)"></a>《程序员面试金典6》(java)</h1><h2 id="1-判断字符唯一"><a href="#1-判断字符唯一" class="headerlink" title="1.判断字符唯一"></a><a href="https://leetcode-cn.com/problems/is-unique-lcci/" target="_blank" rel="noopener">1.判断字符唯一</a></h2><p><strong>思路：</strong></p><ul><li><strong>直接用String类的方法，无需额外数据结构</strong></li></ul><p>​    indexOf( ) ，lastIndexOf( )    从第i个字符以后查找i位置字符索引，存在重复则查到索引大于-1，否则返回-1。</p><p>​    replace( )   如果字符唯一则将字符替换成<strong>空串</strong>，字符串长度只减一。</p><pre><code class="java">class Solution {     public boolean isUnique(String astr) {         int l = astr.length();          String temp;          for (int i=0;i&lt;l;i++){              temp=astr;              if ((temp.replace(String.valueOf(temp.charAt(i)),&quot;&quot;)).length()!=l-1)                  return false;          }          return  true;      } }</code></pre><ul><li><p><strong>用额外数据结构</strong></p><p>数组    </p><p>​            1.双循环直接查找。</p><p>​            2.sort后比较相邻位置</p><pre><code class="java">class Solution {    public boolean isUnique(String astr) {        char[] c = astr.toCharArray();        Arrays.sort(c);        for (int i=0;i&lt;c.length-1;i++){            if (c[i]==c[i+1])                return false;        }        return true;    }}</code></pre><p>HashSet  比较集合长度和数组长度是否相等判重</p><pre><code class="java">class Solution {    public boolean isUnique(String astr) {        char[]c = astr.toCharArray();        Set set = new HashSet();        for (char a:c)            set.add(a);        if (set.size()!=c.length)            return false;        return true;    }}</code></pre><p>Bitset  判断该位置有没有元素判重，无则加入</p><pre><code class="java">class Solution {    public boolean isUnique(String astr) {        BitSet set = new BitSet();        for (char a:astr.toCharArray()){            if (set.get(a))                return false;            set.set(a);        }        return true;    }}</code></pre><p>Map  键唯一特点，将字符串每个字符设为键判重</p><pre><code class="java">class Solution {    public boolean isUnique(String astr) {        Map map = new HashMap();        for (char c:astr.toCharArray()){            if (map.containsKey(c))                return false;            map.put(c,0);        }        return true;    }}</code></pre></li></ul><h2 id="2-判定是否互为字符重排"><a href="#2-判定是否互为字符重排" class="headerlink" title="2.判定是否互为字符重排"></a>2.<a href="https://leetcode-cn.com/problems/check-permutation-lcci/" target="_blank" rel="noopener">判定是否互为字符重排</a></h2><p><strong>思路：</strong></p><p>题意即判断两个字符串的字符相同且相同字符数量也相同。</p><ul><li>不用库函数，首先长度相同，运用两个字符数组相同字符数量也相同特点，需要一个额外字符数组长度为128存字符数，遍历两个字符数组的每个字符，对应额外数组的索引位置一个加一个减，最后根据额外字符数组是否都为0判断。</li></ul><ul><li>Map 字符为键，相同字符数量为值，可以用两个map，直接eauqls比较两个map是否相同，也可以一个map一个数组,每次匹配到map值不为0就减一，直到数组比较完，前提是两个字符串长度相同。</li></ul><ul><li>先数组排序然后equals比较是否相同。</li></ul><pre><code class="java">class Solution {    public boolean CheckPermutation(String s1, String s2) {        char[] c1 = s1.toCharArray();        char[] c2 = s2.toCharArray();        Arrays.sort(c1);        Arrays.sort(c2);        return Arrays.equals(c1,c2);    }}</code></pre><ul><li>StringBuilder  可以删除指定位置的值deleteCharAt(int index) ，只要将一个匹配另一个StringBuilder，找不到则返回false，找到则删除，当两个长度相同，直到数组匹配完就返回true。</li></ul><pre><code class="java">class Solution {    public boolean CheckPermutation(String s1, String s2) {        if (s1.length() != s2.length()) {            return false;        }        StringBuilder s = new StringBuilder(s2);        for (int i = 0, length = s1.length(); i &lt; length; i++) {            if (s.indexOf(String.valueOf(s1.charAt(i))) == -1) {                return false;            }            s.deleteCharAt(s.indexOf(String.valueOf(s1.charAt(i))));        }        return true;    }}</code></pre><h2 id="3-URL化"><a href="#3-URL化" class="headerlink" title="3.URL化"></a>3.<a href="https://leetcode-cn.com/problems/string-to-url-lcci/" target="_blank" rel="noopener">URL化</a></h2><p><strong>思路：</strong></p><ul><li>初步想法：遍历字符数组，读到空格在新数组中依次添加三个字符。由于S在length长度之后还可能有空格，所以需要一个控制变量j来控制长度为length。最后新数组由于长度过长后面有很多空字符，转成字符串需要用trim()去掉空格。</li></ul><pre><code class="java">class Solution {    public String replaceSpaces(String S, int length) {        //char[]c = new char[3*length];        char[]c = new char[S.length()];        int i=0,j=0;        for (char s:S.toCharArray()){            if (j&lt;length){                if (s==&#39; &#39;){                    c[i]=&#39;%&#39;;                    c[i+1]=&#39;2&#39;;                    c[i+2]=&#39;0&#39;;                    i+=3;                }else{                    c[i]=s;                    i+=1;                }                j++;            }        }       // String s1=String.valueOf(c);       // return s1.trim();是前后空格都去掉，实际只需要判断后面        //return String.valueOf(c).substring(0,i);        return new String(ans, 0, i);    }}</code></pre><ul><li>直接用库函数替换</li></ul><pre><code class="java">class Solution {    public String replaceSpaces(String S, int length) {        return S.substring(0,length).replaceAll(&quot; &quot;,&quot;%20&quot;);    }}</code></pre><ul><li>Stringbuilder可以直接append字符串</li></ul><pre><code class="java">class Solution {    public String replaceSpaces(String S, int length) {        StringBuilder sb = new StringBuilder();        for (int i=0;i&lt;S.length()&amp;&amp;i&lt;length;i++){            if (S.charAt(i)==&#39; &#39;)                sb.append(&quot;%20&quot;);            else{                sb.append(S.charAt(i));            }        }        return sb.toString();    }}</code></pre><h2 id="4-回文排列"><a href="#4-回文排列" class="headerlink" title="4.回文排列"></a>4.<a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/" target="_blank" rel="noopener">回文排列</a></h2><p><strong>思路：</strong>回文串满足的特点：<strong>最多只能有一个字符数量是奇数</strong>。所以可以统计相同字符数量看奇数的数量是否&lt;=1。</p><pre><code class="java">class Solution {    public boolean canPermutePalindrome(String s) {        int[] ascii = new int[256];        int count = 0;        for(int i = 0;i&lt;s.length();i++){            ascii[s.charAt(i)]++;            if((ascii[s.charAt(i)] &amp; 1) == 1){                count++;            }else{                count--;            }        }        return count &lt;= 1;    }}</code></pre><ul><li>数组先排序，然后两个两个读，相同则继续读，不同则记录k加1，并且再读一个，和前面相同则继续读。记录大于1则false。<strong>需要判断i是否指向了最后一个位置，否则可能数组越界，如果是的话则说明最后一个单着，k+1</strong>。</li></ul><pre><code class="java">class Solution {    public boolean canPermutePalindrome(String s) {        char[]c=s.toCharArray();        int k=0;        Arrays.sort(c);        for (int i=0;i&lt;c.length;i++){            if (i+1&lt;c.length&amp;&amp;c[i]==c[i+1])                i++;            else {                k++;                if (k&gt;1)                    return false;            }        }        return true;    }}</code></pre><ul><li>HashSet 或者栈。遍历字符，检查HashSet，有则删除，没有则添加。最后根据集合大小判断。</li></ul><pre><code class="java">class Solution {    public boolean canPermutePalindrome(String s) {        HashSet hs = new HashSet();        for (char c:s.toCharArray()){            if (hs.contains(c)){                hs.remove(c);            }else{                hs.add(c);            }        }        if (hs.size()&gt;1)            return false;        return  true;    }}</code></pre><h2 id="5-一次编辑"><a href="#5-一次编辑" class="headerlink" title="5.一次编辑"></a>5.<a href="https://leetcode-cn.com/problems/one-away-lcci/" target="_blank" rel="noopener">一次编辑</a></h2><p><strong>思路：</strong>首先根据长度排除所有长度差大于等于2的。然后可以分三种情况再判断</p><p>​            1.如果first.length()+1=second.length()</p><p>​                    则需要判断是否可以添加一个字符。同步遍历比较，当不同时，读second下一个，相同则把记录当前不同的次数变量k++。然后再继续同步遍历，如果再找到不同则返回false；</p><p>​            2.如果first.length()=second.length()</p><p>​                    则需要判断是否替换一个字符。同步遍历比较到不同时，则把记录当前不同的次数变量k++，然后继续遍历，如果再找到不同则返回false；</p><p>​            3.如果first.length()-1=second.length()</p><p>​                    则需要判断是否可以删除一个字符，与第一种情况first和second反过来即可。</p><blockquote><p>改了很久的bug。。。。终于过了!!!!这种朴素的想法真的是漏洞太多了，我太难了。</p><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时 :2 ms, 在所有 Java 提交中击败了99.42%的用户</p><p>内存消耗 :39.6 MB, 在所有 Java 提交中击败了100.00%的用户</p></blockquote><pre><code class="java">class Solution {    public boolean oneEditAway(String first, String second) {        if  (Math.abs(first.length()-second.length())&gt;=2)            return false;        if ((first.length()==0||second.length()==0)&amp;&amp;Math.abs(first.length()-second.length())==1)            return true;        char[] a = first.toCharArray();        char[] b = second.toCharArray();        int k=0;        if (first.length()==second.length()){            for (int i=0;i&lt;first.length();i++){                if (a[i]!=b[i])                    k++;                if (k&gt;1)                    return false;            }        }        else if (first.length()-1==second.length()) {            for (int i = 0, j = 0; i &lt; first.length(); i++, j++) {                if (k &lt; 1 &amp;&amp; a[i] != b[j] &amp;&amp; a[i + 1] == b[j]) {                    k++;                    i++;                } else if (a[i] == b[j]&amp;&amp;j&lt;second.length()-1){                }else if (a[i] == b[j]&amp;&amp;j==second.length()-1){                    break;                }                else {                    return false;                }            }        }        else{            for (int i = 0, j = 0; i &lt; second.length(); i++, j++) {                if (k &lt; 1 &amp;&amp; b[i] != a[j] &amp;&amp; b[i + 1] == a[j]) {                    k++;                    i++;                } else if (b[i]==a[j]&amp;&amp;j&lt;first.length()-1){                }else if (b[i]==a[j]&amp;&amp;j==first.length()-1)                    break;                else {                    return false;                }            }        }        return true;    }}</code></pre><ul><li>优化代码：可以通过将两个串长的那个一直用变量first表示，短的用second表示，这样可以将第一种和第三种情况合并。</li></ul><pre><code class="java">class Solution {    public boolean oneEditAway(String first, String second) {        //小的字符串用second，大的first        if(first.length() &gt; second.length()){            String temp = first;            first = second;            second = temp;        }        if(second.length()-first.length()&gt;1){            return false;        }else {            if(second.length() == first.length()){                //判断是否可以替换,两处相同位置不同就return false                int count = 0;                for (int i = 0; i &lt;first.length() ; i++) {                    if(first.charAt(i) != second.charAt(i)){                        count++;                        if(count == 2){                            return false;                        }                    }                }            }else {                //判断是否通过加就行                for (int i = 0; i &lt;first.length() ; i++) {                    if(first.charAt(i)!=second.charAt(i) &amp;&amp; first.charAt(i) !=second.charAt(i+1)){                        return false;                    }                }            }        }        return true;    }}</code></pre><p>定位到第一个不同的地方，然后比较子串是否相同。将长度相同和差一这两种情况通过改变比较子串的开始位置来当成整体实现。</p><pre><code class="java">class Solution {    public boolean oneEditAway(String first, String second) {        if (first == null || second == null) return false;        int len1 = first.length();        int len2 = second.length();        if (Math.abs(len1 - len2) &gt; 1) return false;        if (len2 &gt; len1) return oneEditAway(second, first);        for (int i = 0; i &lt; len2; i++){            if (first.charAt(i) != second.charAt(i)){                // 如果是长度相同字符串，那就比较下一个，如果长度不一样，那就从该字符开始进行比较。                return first.substring(i + 1).equals(second.substring(len1 == len2 ? i + 1 : i));            }        }        return true;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>程序员面试金典6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>疫情期间</title>
    <link href="/2020/05/08/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4/"/>
    <url>/2020/05/08/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="理直气壮做宅男的日子"><a href="#理直气壮做宅男的日子" class="headerlink" title="理直气壮做宅男的日子"></a>理直气壮做宅男的日子</h1><img src="6.jpeg" srcset="/img/loading.gif" style="zoom:80%;" /><p>​    </p><p>这个寒假注定是印象深刻的。</p><p>​    当初放假打包想着精简行李的时候一定不会想到，此刻的我会为没有衣服穿而发愁。毕竟已经立夏了，我躺在床上，望着仅带的两件冬装，悔不当初。这只是这次疫情影响得很小的一个方面，更广泛的涉及到了生活方式、学习进度、精神层面以及人生方向。</p><ul><li><p><strong>生活方式</strong></p><blockquote><p>这是最直观的一个方面。本来便属于那种除了旅行和吃喝，不太愿意出去的人，这次疫情为了响应国家号召，理所当然的挖掘出百分百宅男属性，游戏、外卖、床三位一体，获得成就一个月不下楼，一个半月不理发与不刮胡子。由于没有束缚，作息也从11-7调到了3-11，获得和平精英荣耀皇冠，云顶之弈白金成就。<strong><em>枯燥</em></strong>。</p><p>最近意识到这种生活方式是非常不负责的，正在积极调整。发誓不熬没有意义的夜，不关心与我无关的事，将精力集中在需要的地方。待陌上花开，可缓缓归矣。</p><img src="4.jpg" srcset="/img/loading.gif" style="zoom: 80%;" /><center>鸭绿江边骑行</center></blockquote></li><li><p><strong>学习进度</strong></p><blockquote><p>这是最惭愧的一个方面。三个月来，学习效率很低，计划容易被琐事打断，吉他还在坚持，虽然收效甚微，但逐渐意识到所有能力几乎都逃不过熟能生巧。自认为之前前进的动力大多来自外部的压力，这种是非常不稳定也不健康的，当对外界充耳不闻时便容易活在自我满足的状态中，这有清朝的前例在，是需要总结和改正的，下一步应该把内在的需求转化为学习的动力源泉，站得越高的人越是向上看的，所以要形成这种良性的内在循环促进提高。</p><p><img src="3.jpg" srcset="/img/loading.gif" style="zoom:80%;" /><img src="5.jpg" srcset="/img/loading.gif" style="zoom:80%;" /></p><center>幼稚->成熟</center><img src="2.jpg" srcset="/img/loading.gif" style="zoom: 80%;" /><center>只有打开软件才会想起来把时间都丢去哪了</center>    </blockquote></li><li><p><strong>精神层面</strong></p><blockquote><p>这是最隐晦的一个方面。就算想得到也是不容易说清楚的。从每天醒来一睁眼就打开手机看昨天的增长人数，到后来的不再刻意关心的麻木。从每天期待各种有价值的新闻去抒发态度，到将新闻软件都卸载。从《后浪》到《非浪》。这三个月应该是我最悠闲的去思考一些东西的时光了。杨绛先生说过：你的主要的问题在于读书不多而想的太多。不得不说，先生的眼光还是准确。我的确就是这样，读书不多却总爱想入非非，也没有个拿得出手的结论。我是一个喜欢和别人争论对错，想要说服别人的人，这点可以说是偏执，在以往的生活中也容易碰壁，希望今后可以多吸收，少输出。</p></blockquote></li></ul><ul><li><p><strong>人生方向</strong></p><blockquote><p>这是最纠结的一个方面。可以说现在还在纠结，可能会一直下去。但我并不认为这样不好，人生就是充满可能性的，每一个阶段所朝的方向也只是这个阶段所拥有的，我不愿意没有纠结过就放弃任意一种可能，但对每个阶段的目标我都希望奔跑前进。最近放弃了做游戏和搞前端的想法，但可能只是近两年的放弃。也放弃了春招，选择了继续学习。如果可以，就人生而言，我希望我在做不规则运动，我不嫉妒直线的快速到达，也不羡慕曲线的平滑过渡。带着好奇和随性来摸索，即便没有归属也没有关系，只因我的眼想要看的更远，我的心可以容纳更多。</p></blockquote><blockquote><p><img src="1.jpg" srcset="/img/loading.gif" alt=""></p><center>窗外的火烧云</center></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2020</tag>
      
      <tag>总结</tag>
      
      <tag>宅</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年计划</title>
    <link href="/2020/04/17/2020%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    <url>/2020/04/17/2020%E5%B9%B4%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="PLAN"><a href="#PLAN" class="headerlink" title="PLAN"></a>PLAN</h1><img src="0.jpg" srcset="/img/loading.gif" style="zoom:200%;" /><ul><li><strong>吉他</strong></li><li><strong>30本书</strong></li><li><strong>秋招</strong></li><li><strong>去三个陌生的城市</strong></li><li><strong>坚持写博客</strong></li><li><strong>记账</strong></li><li><strong>论文</strong></li><li><strong>未完待续……</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>2020</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
